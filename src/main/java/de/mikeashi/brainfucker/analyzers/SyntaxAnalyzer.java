package de.mikeashi.brainfucker.analyzers;

import de.mikeashi.brainfucker.ast.AST;
import de.mikeashi.brainfucker.ast.ASTNode;
import de.mikeashi.brainfucker.exceptions.InvalidSyntaxException;
import de.mikeashi.brainfucker.expression.RootExpression;
import de.mikeashi.brainfucker.expression.source.*;
import de.mikeashi.brainfucker.tokens.Token;

import java.util.stream.Stream;

/**
 * Syntax analyser which generates the programme AST tree while checking for syntax errors  .
 *
 * @author Mike Ashi
 */
public class SyntaxAnalyzer {
    final Stream<Token> tokens;

    /**
     * Creates a new SyntaxAnalyzer instance.
     *
     * @param tokens tokens generated by the Lexer.
     */
    public SyntaxAnalyzer(Stream<Token> tokens) {
        this.tokens = tokens;
    }

    /**
     * @return the AST which represents the programme.
     * @throws InvalidSyntaxException
     */
    public AST getAST() {
        ASTNode rootNode = new ASTNode(new RootExpression());
        AST ast = new AST(rootNode);
        ASTNode currentNode = rootNode;

        int loopCounter = 0;

        for (Token token : (Iterable<Token>)tokens::iterator) {
            ASTNode newNode = null;
            ASTNode nextNode = null;

            switch (token) {
                case RIGHT_SHIFT:
                    newNode = new ASTNode(new PointerRightExpression());
                    break;
                case LEFT_SHIFT:
                    newNode = new ASTNode(new PointerLeftExpression());
                    break;
                case INCREASE:
                    newNode = new ASTNode(new IncrementExpression());
                    break;
                case DECREASE:
                    newNode = new ASTNode(new DecrementExpression());
                    break;
                case OUTPUT:
                    newNode = new ASTNode(new OutputExpression());
                    break;
                case INPUT:
                    newNode = new ASTNode(new InputExpression());
                    break;
                case RIGHT_BRACKET:
                    loopCounter++;
                    newNode = new ASTNode(new LoopExpression());
                    nextNode = newNode;
                    break;
                case LEFT_BRACKET:
                    if (loopCounter == 0) {
                        throw new InvalidSyntaxException("A ] has been found without a matching opening [.");
                    }
                    loopCounter--;
                    nextNode = currentNode.getParent();
                    break;
            }

            if (newNode != null) {
                currentNode.addChild(newNode);
            }

            if (nextNode != null) {
                currentNode = nextNode;
            }
        }

        if (loopCounter > 0) {
            throw new InvalidSyntaxException("A ] is missing.");
        }

        return ast;
    }
}
